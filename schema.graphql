# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface DistributionResultChunk {
    endTimestamp: DateTime!
    isAnalysis: Boolean!
    nrDataPoints: Int!
    startTimestamp: DateTime!
}

interface PerformanceMetricConfigInterface {
    enabled: Boolean!
    enabledEstimated: Boolean!
    enabledRealized: Boolean!
    metric: PerformanceMetric!
    threshold: Threshold
}

interface Result {
    analysisType: AnalysisType!
    calculatorType: CalculatorType!
    modelId: Int!
    tags: [String!]!
}

interface ResultData {
    endTimestamp: DateTime!
    isAnalysis: Boolean!
    nrDataPoints: Int!
    startTimestamp: DateTime!
}

interface Threshold {
    id: ID!
    name: String!
    type: ThresholdType!
}

interface ThresholdBase {
    name: String!
}

interface Thresholdbase {
    id: ID!
    name: String!
    type: ThresholdType!
}

union ModelResultInvalidationRequired = Model | ResultInvalidationRequired

union TagTagAlreadyExists = Tag | TagAlreadyExists

union TagTagAlreadyExistsTagNotFound = Tag | TagAlreadyExists | TagNotFound

union UserApiTokenTokenNotFound = TokenNotFound | UserApiToken

union UserNotificationSettingsUserNotFound = UserNotFound | UserNotificationSettings

type ApplicationSettings {
    auth: AuthenticationSettings
    maxUploadSize: Int!
    notifications: NotificationSettings
    usageStatistics: Boolean
}

type AuthenticationSettings {
    mode: AuthMode!
    oidcProviders: [OidcProvider!]!
}

type BusinessValueMetricConfig implements PerformanceMetricConfigInterface {
    enabled: Boolean!
    enabledEstimated: Boolean!
    enabledRealized: Boolean!
    falseNegativeWeight: Float!
    falsePositiveWeight: Float!
    metric: PerformanceMetric!
    threshold: Threshold
    trueNegativeWeight: Float!
    truePositiveWeight: Float!
}

type ChunkingConfig {
    chunking: Chunking!
    enabled: Boolean!
    nrOfRows: Int
}

type Column {
    className: String
    columnType: ColumnType!
    dataType: String!
    name: String!
}

type ConceptShiftMetricConfig {
    enabled: Boolean!
    metric: ConceptShiftMetric!
    threshold: Threshold
}

type ConstantThreshold implements Threshold & ThresholdBase & Thresholdbase {
    id: ID!
    lower: Float
    name: String!
    type: ThresholdType!
    upper: Float
}

type DataQualityMetricConfig {
    enabled: Boolean!
    metric: DataQualityMetric!
    normalize: Boolean!
    threshold: Threshold
}

type DataSource {
    columns: [Column!]!
    events(filter: DataSourceEventsFilter): [DataSourceEvent!]!
    hasAnalysisData: Boolean!
    hasReferenceData: Boolean!
    head(nrRows: Int! = 10): JSON!
    id: ID!
    name: String!
    nrRows: Int
}

type DataSourceEvent {
    causedBy: User!
    eventType: DataSourceEventType!
    id: ID!
    nrRows: Int
    timestamp: DateTime!
}

type DataSourceInspectData {
    columns: [Column!]!
    head: JSON!
}

type DatasetCacheRef {
    id: String!
}

type EmailNotificationSettings {
    enabled: Boolean!
    resend: EmailResendSettings
    smtp: EmailSmtpSettings
}

type EmailResendSettings {
    apiKey: String!
    sender: String!
}

type EmailSmtpSettings {
    host: String!
    password: String
    port: Int!
    sender: String!
    useTls: Boolean!
    username: String
}

type EvaluationModel {
    classificationThreshold: Float!
    config: EvaluationModelConfig!
    createdAt: DateTime!
    createdBy: User
    evaluationDataSource: DataSource!
    hypothesis: EvaluationHypothesis!
    id: Int!
    kpm: PerformanceMetric!
    kpmResult: EvaluationPerformanceResult
    latestRun: EvaluationRun
    name: String!
    problemType: ProblemType!
    referenceDataSource: DataSource!
    results(filter: EvaluationModelResultsFilter): [EvaluationPerformanceResult!]!
    runs: [EvaluationRun!]!
}

type EvaluationModelConfig {
    metrics: [EvaluationPerformanceMetricConfig!]!
}

type EvaluationPerformanceMetricConfig {
    enabled: Boolean!
    hdiWidth: Float
    metric: PerformanceMetric!
    ropeLowerBound: Float
    ropeUpperBound: Float
}

type EvaluationPerformanceResult {
    config: EvaluationPerformanceMetricConfig!
    experimentDistribution: [EvaluationResultDistributionDataPoint!]!
    hdiData: [EvaluationResultHdiDataPoint!]!
    hdiWidthReached: Boolean!
    latestHdi: EvaluationResultHdiDataPoint
    metric: PerformanceMetric!
    modelId: Int!
    referenceDistribution: [EvaluationResultDistributionDataPoint!]!
    status: EvaluationStatus!
    tags: [String!]!
}

type EvaluationResultDistributionDataPoint {
    x: Float!
    y: Float!
}

type EvaluationResultHdiDataPoint {
    cut: Float!
    generatedBy: EvaluationRun
    hdiLower: Float!
    hdiUpper: Float!
    nrObservations: Int!
}

type EvaluationRun {
    completedAt: DateTime
    events(eventType: RunEventType): [EvaluationRunEvent!]!
    id: Int!
    log: String
    ranSuccessfully: Boolean
    scheduledFor: DateTime
    startedAt: DateTime
    state: RunState!
}

type EvaluationRunEvent {
    causedBy: User
    currentStep: Int
    description: String
    eventType: RunEventType!
    nrSteps: Int
    ranSuccessfully: Boolean
    scheduledFor: DateTime
    timestamp: DateTime!
}

type Experiment {
    createdAt: DateTime!
    createdBy: User
    dataSource: DataSource!
    experimentType: ExperimentType!
    id: Int!
    kem: String!
    kemResult: ExperimentResultMetric
    latestRun: ExperimentRun
    name: String!
    results(filter: ExperimentResultsFilter): [ExperimentResultMetric!]!
    runs: [ExperimentRun!]!
    runtimeConfig: ExperimentRuntimeConfig!
}

type ExperimentDataSourceInspectData {
    metrics: [ExperimentMetric!]!
}

type ExperimentMetric {
    groups: [String!]!
    name: String!
    valid: Boolean!
}

type ExperimentMetricConfig {
    hdiWidth: Float!
    metric: String!
    ropeLowerBound: Float!
    ropeUpperBound: Float!
}

type ExperimentResultDistributionDataPoint {
    x: Float!
    y: Float!
}

type ExperimentResultHdiDataPoint {
    cut: Float!
    generatedBy: ExperimentRun!
    hdiLower: Float!
    hdiUpper: Float!
    nrObservations: Int!
}

type ExperimentResultMetric {
    config: ExperimentMetricConfig!
    distribution: [ExperimentResultDistributionDataPoint!]!
    experimentId: Int!
    hdiData: [ExperimentResultHdiDataPoint!]!
    hdiWidthReached: Boolean!
    id: Int!
    latestHdi: ExperimentResultHdiDataPoint
    metric: String!
    status: ExperimentStatus!
    tags: [String!]!
}

type ExperimentRun {
    completedAt: DateTime
    events: [ExperimentRunEvent!]!
    id: Int!
    log: String
    ranSuccessfully: Boolean
    scheduledFor: DateTime
    startedAt: DateTime
    state: RunState!
}

type ExperimentRunEvent {
    causedBy: User
    currentStep: Int
    description: String
    eventType: RunEventType!
    nrSteps: Int
    ranSuccessfully: Boolean
    scheduledFor: DateTime
    timestamp: DateTime!
}

type ExperimentRuntimeConfig {
    metrics: [ExperimentMetricConfig!]!
}

type KdeDistributionDataPoint {
    density: Float!
    value: Float!
}

type KdeDistributionIndex {
    cumulativeDensity: Float!
    density: Float!
    value: Float!
}

type KdeDistributionResult implements Result {
    analysisType: AnalysisType!
    calculatorType: CalculatorType!
    chunks(filter: ResultDataFilter): [KdeDistributionResultChunk!]!
    columnName: String!
    modelId: Int!
    tags: [String!]!
}

type KdeDistributionResultChunk implements DistributionResultChunk & ResultData {
    data: [KdeDistributionDataPoint!]!
    endTimestamp: DateTime!
    indices: [KdeDistributionIndex!]!
    isAnalysis: Boolean!
    nrDataPoints: Int!
    startTimestamp: DateTime!
}

type MetricConfigPerformance implements PerformanceMetricConfigInterface {
    enabled: Boolean!
    enabledEstimated: Boolean!
    enabledRealized: Boolean!
    metric: PerformanceMetric!
    threshold: Threshold
}

type Model {
    createdAt: DateTime!
    dataSources(filter: DataSourcesFilter): [DataSource!]!
    hasInitialRunCompleted: Boolean!
    id: Int!
    latestRun: Run
    name: String!
    nextRun: Run
    problemType: ProblemType!
    referenceEndTimestamp: DateTime
    referenceStartTimestamp: DateTime
    results(filter: ModelResultsFilter, includeDisabled: Boolean! = false): [Result!]!
    runnerConfig: JSON!
    runs: [Run!]!
    runtimeConfig: RuntimeConfig!
    schedules: [Schedule!]!
}

type MultivariateDriftMethodConfig {
    enabled: Boolean!
    method: MultivariateDriftMethod!
    threshold: Threshold
}

type Mutation {
    add_data_to_data_source(input: DataSourceDataInput!): DataSource!
    add_model_data_source(input: AddDataSourceToModelInput!): DataSource!
    cancel_evaluation_model_run(evaluationRunId: Int!): EvaluationRun!
    cancel_experiment_run(runId: Int!): ExperimentRun!
    create_evaluation_model(input: CreateEvaluationModelInput!): EvaluationModel!
    create_experiment(input: CreateExperimentInput!): Experiment!
    create_monitoring_model(model: CreateModelInput!): Model!
    create_tag(input: CreateTagInput!): TagTagAlreadyExists!
    create_threshold(input: CreateThresholdInput!): ThresholdBase!
    create_user_api_token(input: UserApiTokenCreateInput!): UserApiTokenCreateResponse!
    delete_data_from_data_source(input: DataSourceDeleteInput!): DataSource!
    delete_data_source(input: DeleteDataSourceInput!): DataSource!
    delete_evaluation_model(evaluationModelId: Int!): EvaluationModel!
    delete_experiment(id: Int!): Experiment!
    delete_monitoring_model(modelId: Int!): Model!
    delete_user_api_token(tokenId: ID!): UserApiTokenTokenNotFound!
    edit_application_settings(settings: EditApplicationSettingsInput!): ApplicationSettings!
    edit_evaluation_model(input: EditEvaluationModelInput!): EvaluationModel!
    edit_experiment(input: EditExperimentInput!): Experiment!
    edit_monitoring_model(input: EditModelInput!): ModelResultInvalidationRequired!
    edit_tag(input: EditTagInput!): TagTagAlreadyExistsTagNotFound!
    edit_user_notification_settings(settings: EditUserNotificationSettingsInput!): UserNotificationSettingsUserNotFound!
    start_evaluation_model_run(evaluationModelId: Int!): EvaluationRun!
    start_experiment_run(experimentId: Int!): ExperimentRun!
    start_monitoring_model_run(modelId: Int!): Run!
    stop_monitoring_model_run(modelId: Int!): Run!
    tag_monitoring_result(input: TagResultInput!): Result!
    untag_monitoring_result(input: TagResultInput!): Result!
    upload_dataset(file: Upload!): DatasetCacheRef!
    upsert_data_in_data_source(input: DataSourceDataInput!): DataSource!
}

type NotificationSettings {
    email: EmailNotificationSettings
    webhook: WebhookNotificationSettings
}

type OidcProvider {
    audience: String!
    authority: String!
    issuer: String!
    redirectUri: String
}

type PerformanceTypeConfig {
    enabled: Boolean!
    type: PerformanceType!
}

type Query {
    application_settings: ApplicationSettings!
    current_user: User!
    evaluation_model(id: Int!): EvaluationModel
    evaluation_model_config: EvaluationModelConfig
    evaluation_models(filter: EvaluationModelsFilter): [EvaluationModel!]!
    experiment(id: Int!): Experiment
    experiments(filter: ExperimentsFilter): [Experiment!]!
    inspect_dataset(input: InspectDataSourceInput!): DataSourceInspectData!
    inspect_experiment_dataset(input: InspectExperimentDataSourceInput!): ExperimentDataSourceInspectData!
    monitoring_model(id: Int!): Model
    monitoring_models(filter: ModelsFilter): [Model!]!
    send_test_email(recipient: String!, settings: EmailSmtpSettingsInput!): Void
    send_test_webhook_call(settings: WebhookNotificationSettingsInput!): Void
    tags(names: [String!]): [Tag!]!
    thresholds: [Threshold!]!
    verify_auth(accessToken: String!, authSettings: AuthenticationSettingsInput!): Boolean!
}

type ResultInvalidationRequired {
    all: Boolean!
    metrics: [ResultRef!]!
    modelId: Int!
}

type ResultRef {
    analysisType: AnalysisType!
    calculatorType: CalculatorType!
    columnName: String
    columnNames: [String!]
    componentName: String
    metricName: String
    modelId: Int!
}

type Run {
    completedAt: DateTime
    events(eventType: RunEventType): [RunEvent!]!
    id: ID!
    log: String
    ranSuccessfully: Boolean
    scheduledFor: DateTime
    startedAt: DateTime
    state: RunState!
}

type RunEvent {
    calculator: CalculatorType
    causedBy: User
    currentStep: Int
    description: String
    eventType: RunEventType!
    nrSteps: Int
    ranSuccessfully: Boolean
    scheduledFor: DateTime
    timestamp: DateTime!
}

type RuntimeConfig {
    conceptShiftMetrics: [ConceptShiftMetricConfig!]!
    dataChunking: [ChunkingConfig!]!
    dataQualityMetrics: [DataQualityMetricConfig!]!
    multivariateDriftMethods: [MultivariateDriftMethodConfig!]!
    performanceMetrics: [PerformanceMetricConfigInterface!]!
    performanceTypes: [PerformanceTypeConfig!]!
    summaryStatsMetrics: [SummaryStatsMetricConfig!]!
    univariateDriftMethods: [UnivariateDriftMethodConfig!]!
}

type Schedule {
    dayOfWeek: DayOfWeek
    frequency: ScheduleFrequency!
    multiplier: Int!
    offsetDays: Int
    time: Time!
}

type StandardDeviationThreshold implements Threshold & ThresholdBase & Thresholdbase {
    id: ID!
    name: String!
    stdLowerMultiplier: Float
    stdUpperMultiplier: Float
    type: ThresholdType!
}

type SummaryStatsMetricConfig {
    enabled: Boolean!
    metric: SummaryStatsMetric!
    threshold: Threshold
}

type Tag {
    name: String!
}

type TagAlreadyExists {
    name: String!
}

type TagNotFound {
    name: String!
}

type ThresholdAlreadyExists implements ThresholdBase {
    name: String!
}

type TimeSeriesDataPoint implements ResultData {
    endTimestamp: DateTime!
    hasAlert: Boolean!
    isAnalysis: Boolean!
    lowerConfidenceBound: Float
    nrDataPoints: Int!
    samplingError: Float
    startTimestamp: DateTime!
    upperConfidenceBound: Float
    value: Float
}

type TimeSeriesResult implements Result {
    analysisType: AnalysisType!
    calculatorType: CalculatorType!
    columnName: String
    columnNames: [String!]
    componentName: String
    data(filter: ResultDataFilter): [TimeSeriesDataPoint!]!
    lastDataPoint: TimeSeriesDataPoint
    lowerThreshold: Float
    metricName: String!
    modelId: Int!
    nrAlerts: Int!
    tags: [String!]!
    upperThreshold: Float
}

type TokenNotFound {
    id: ID!
}

type UnivariateDriftMethodConfig {
    enabled: Boolean!
    enabledCategorical: Boolean!
    enabledContinuous: Boolean!
    method: UnivariateDriftMethod!
    threshold: Threshold
}

type User {
    apiTokens: [UserApiToken!]!
    businessKey: String!
    email: String
    familyName: String
    firstName: String
    id: ID!
    name: String
    notificationSettings: UserNotificationSettings!
}

type UserApiToken {
    createdAt: DateTime!
    description: String
    id: ID!
}

type UserApiTokenCreateResponse {
    createdAt: DateTime!
    description: String
    id: ID!
    token: String!
}

type UserNotFound {
    id: ID!
}

type UserNotificationSettings {
    emailEnabled: Boolean!
    emailRecipient: String
}

type ValueCountDistributionDataPoint {
    count: Int!
    density: Float!
    value: String!
}

type ValueCountDistributionResult implements Result {
    analysisType: AnalysisType!
    calculatorType: CalculatorType!
    chunks(filter: ResultDataFilter): [ValueCountDistributionResultChunk!]!
    columnName: String!
    modelId: Int!
    tags: [String!]!
}

type ValueCountDistributionResultChunk implements DistributionResultChunk & ResultData {
    data: [ValueCountDistributionDataPoint!]!
    endTimestamp: DateTime!
    isAnalysis: Boolean!
    nrDataPoints: Int!
    startTimestamp: DateTime!
}

type WebhookNotificationHeader {
    key: String!
    value: String!
}

type WebhookNotificationSettings {
    additionalHeaders: [WebhookNotificationHeader!]!
    address: String!
    enabled: Boolean!
}

enum AnalysisType {
    CONCEPT_SHIFT
    DATA_QUALITY
    DISTRIBUTION
    ESTIMATED_PERFORMANCE
    FEATURE_DRIFT
    REALIZED_PERFORMANCE
    SUMMARY_STATS
}

enum AuthMode {
    ANONYMOUS
    LOCAL
    OIDC
}

enum AzureBlobAuthenticationMode {
    ACCESS_KEY
    ANONYMOUS
    MANAGED_IDENTITY
    SAS_TOKEN
}

enum CalculatorType {
    CATEGORICAL_DISTRIBUTION
    CBPE
    CONTINUOUS_DISTRIBUTION
    DLE
    MCBPE
    MISSING_VALUES
    MULTIVARIATE_DRIFT
    PERFORMANCE_CALCULATION
    RCS
    SUMMARY_STATS_AVG
    SUMMARY_STATS_MEDIAN
    SUMMARY_STATS_ROW_COUNT
    SUMMARY_STATS_STD
    SUMMARY_STATS_SUM
    UNIVARIATE_DRIFT
    UNSEEN_VALUES
}

enum Chunking {
    DAILY
    HOURLY
    MONTHLY
    NUMBER_OF_ROWS
    QUARTERLY
    WEEKLY
    YEARLY
}

enum ColumnType {
    CATEGORICAL_FEATURE
    CONTINUOUS_FEATURE
    FAIL_COUNT
    GROUP_NAME
    IDENTIFIER
    IGNORED
    METRIC_NAME
    PREDICTION
    PREDICTION_SCORE
    SUCCESS_COUNT
    TARGET
    TIMESTAMP
}

enum ConceptShiftMetric {
    ACCURACY
    F1
    MAGNITUDE
    PRECISION
    RECALL
    ROC_AUC
    SPECIFICITY
}

enum DataPeriod {
    ANALYSIS
    REFERENCE
}

enum DataQualityMetric {
    MISSING_VALUES
    UNSEEN_VALUES
}

enum DataSourceEventType {
    CREATED
    DATA_ADDED
    DATA_REMOVED
    DATA_UPDATED
}

enum DayOfWeek {
    FRIDAY
    MONDAY
    SATURDAY
    SUNDAY
    THURSDAY
    TUESDAY
    WEDNESDAY
}

enum EvaluationHypothesis {
    MODEL_PERFORMANCE_NO_WORSE_THAN_REFERENCE
    MODEL_PERFORMANCE_WITHIN_RANGE
}

enum EvaluationStatus {
    ACCEPTED
    ONGOING
    REJECTED
}

enum ExperimentStatus {
    ACCEPTED
    ONGOING
    REJECTED
}

enum ExperimentType {
    A_B_TESTING
}

enum MultivariateDriftMethod {
    PCA_RECONSTRUCTION_ERROR
}

enum PerformanceMetric {
    ACCURACY
    AVERAGE_PRECISION
    BUSINESS_VALUE
    CONFUSION_MATRIX
    F1
    MAE
    MAPE
    MSE
    MSLE
    PRECISION
    RECALL
    RMSE
    RMSLE
    ROC_AUC
    SPECIFICITY
}

enum PerformanceType {
    CBPE
    DLE
    MCBPE
    REALIZED
}

enum ProblemType {
    BINARY_CLASSIFICATION
    MULTICLASS_CLASSIFICATION
    REGRESSION
}

enum ProductType {
    EVALUATION
    EXPERIMENT
    MONITORING
}

enum RunEventType {
    CANCELLED
    COMPLETED
    ERROR
    PROGRESS
    SCHEDULED
    STARTED
    TIMEOUT
    WARNING
}

enum RunState {
    CANCELLING
    COMPLETED
    RUNNING
    SCHEDULED
}

enum S3AuthenticationMode {
    ACCESS_KEY
    ANONYMOUS
    INTEGRATED
}

enum ScheduleFrequency {
    DAILY
    HOURLY
    MONTHLY
    QUARTERLY
    WEEKLY
    YEARLY
}

enum SummaryStatsMetric {
    ROWS_COUNT
    SUMMARY_STATS_AVG
    SUMMARY_STATS_MEDIAN
    SUMMARY_STATS_STD
    SUMMARY_STATS_SUM
}

enum ThresholdType {
    CONSTANT
    STANDARD_DEVIATION
}

enum UnivariateDriftMethod {
    CHI2
    HELLINGER
    JENSEN_SHANNON
    KOLMOGOROV_SMIRNOV
    L_INFINITY
    WASSERSTEIN
}

"Date with time (isoformat)"
scalar DateTime

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"Time (isoformat)"
scalar Time

scalar Upload

"Represents NULL values"
scalar Void

input AddDataSourceToModelInput {
    dataSource: CreateDataSourceInput!
    modelId: ID!
}

input AuthenticationSettingsInput {
    localUsers: [UserCredentialInput!]
    mode: AuthMode!
    oidcProviders: [OidcProviderInput!]
}

input AzureBlobStorageInput {
    accessKey: String
    accountName: String!
    authenticationMode: AzureBlobAuthenticationMode!
    container: String!
    path: String!
    sasToken: String
}

input BusinessValueMetricConfigInput {
    falseNegativeWeight: Float!
    falsePositiveWeight: Float!
    trueNegativeWeight: Float!
    truePositiveWeight: Float!
}

input CacheStorageInput {
    id: String!
}

input ChunkingConfigInput {
    chunking: Chunking!
    enabled: Boolean!
    nrOfRows: Int
}

input ColumnInput {
    className: String
    columnType: ColumnType!
    dataType: String!
    name: String!
}

input ColumnTypeInput {
    columnType: ColumnType!
    name: String!
}

input ConceptShiftMetricConfigInput {
    enabled: Boolean!
    metric: ConceptShiftMetric!
    threshold: ThresholdRefInput
}

input ConstantThresholdInput {
    lower: Float
    upper: Float
}

input CreateDataSourceInput {
    columns: [ColumnInput!]!
    hasAnalysisData: Boolean!
    hasReferenceData: Boolean!
    name: String!
    storageInfo: StorageInput
}

input CreateEvaluationModelInput {
    classificationThreshold: Float!
    evaluationDataSource: CreateDataSourceInput
    hypothesis: EvaluationHypothesis!
    kpm: PerformanceMetric!
    metrics: [EvaluationPerformanceMetricConfigInput!]!
    name: String!
    problemType: ProblemType!
    referenceDataSource: CreateDataSourceInput!
}

input CreateExperimentInput {
    config: ExperimentRuntimeConfigInput!
    dataSource: CreateDataSourceInput!
    experimentType: ExperimentType!
    kem: String!
    name: String!
}

input CreateModelInput {
    chunkAggregation: Chunking!
    dataSources: [CreateDataSourceInput!]! = []
    mainPerformanceComponent: String
    mainPerformanceMetric: PerformanceMetric
    name: String!
    numberOfRows: Int
    problemType: ProblemType!
    referenceEndTimestamp: DateTime
    referenceStartTimestamp: DateTime
}

input CreateTagInput {
    name: String!
}

input CreateThresholdInput {
    constant: ConstantThresholdInput
    name: String!
    standardDeviation: StandardDeviationThresholdInput
}

input DataQualityMetricConfigInput {
    enabled: Boolean!
    metric: DataQualityMetric!
    normalize: Boolean!
    threshold: ThresholdRefInput
}

input DataSourceDataInput {
    id: ID!
    storageInfo: StorageInput!
}

input DataSourceDeleteInput {
    dataIds: StorageInput!
    id: ID!
}

input DataSourceEventsFilter {
    causedByUserId: ID
    eventType: DataSourceEventType
}

input DataSourcesFilter {
    hasAnalysisData: Boolean
    hasReferenceData: Boolean
    name: String
}

input DeleteDataSourceInput {
    id: ID!
}

input EditApplicationSettingsInput {
    auth: AuthenticationSettingsInput
    notifications: NotificationSettingsInput
    usageStatistics: Boolean
}

input EditDataSourceColumnTypesInput {
    columns: [ColumnTypeInput!]!
    id: ID!
}

input EditEvaluationModelInput {
    classificationThreshold: Float
    hypothesis: EvaluationHypothesis
    kpm: PerformanceMetric
    modelId: Int!
    name: String
    problemType: ProblemType
    runtimeConfig: EditEvaluationModelRuntimeConfigInput
}

input EditEvaluationModelRuntimeConfigInput {
    metrics: [EditEvaluationPerformanceMetricConfigInput!]
}

input EditEvaluationPerformanceMetricConfigInput {
    enabled: Boolean
    hdiWidth: Float
    metric: PerformanceMetric!
    ropeLowerBound: Float
    ropeUpperBound: Float
}

input EditExperimentInput {
    config: EditExperimentRuntimeConfigInput
    experimentId: Int!
    kem: String
    name: String
}

input EditExperimentMetricConfigInput {
    hdiWidth: Float!
    metric: String!
    ropeLowerBound: Float!
    ropeUpperBound: Float!
}

input EditExperimentRuntimeConfigInput {
    metrics: [EditExperimentMetricConfigInput!]
}

input EditModelInput {
    allowInvalidatingResults: Boolean! = false
    dataSources: [EditDataSourceColumnTypesInput!]
    modelId: Int!
    name: String
    referenceEndTimestamp: DateTime
    referenceStartTimestamp: DateTime
    runtimeConfig: EditRuntimeConfigInput
    schedules: [EditScheduleInput!]
}

input EditRuntimeConfigInput {
    conceptShiftMetrics: [ConceptShiftMetricConfigInput!]
    dataChunking: [ChunkingConfigInput!]
    dataQualityMetrics: [DataQualityMetricConfigInput!]
    multivariateDriftMethods: [MultivariateDriftMethodConfigInput!]
    performanceMetrics: [PerformanceMetricConfigInput!]
    performanceTypes: [PerformanceTypeConfigInput!]
    summaryStatsMetrics: [SummaryStatsMetricConfigInput!]
    univariateDriftMethods: [UnivariateDriftMethodConfigInput!]
}

input EditScheduleInput {
    dayOfWeek: DayOfWeek
    frequency: ScheduleFrequency!
    multiplier: Int!
    offsetDays: Int
    time: Time!
}

input EditTagInput {
    name: String!
    originalName: String!
}

input EditUserNotificationSettingsInput {
    emailEnabled: Boolean!
    emailRecipient: String
    userId: ID
}

input EmailNotificationSettingsInput {
    enabled: Boolean
    resend: EmailResendSettingsInput
    smtp: EmailSmtpSettingsInput
}

input EmailResendSettingsInput {
    apiKey: String!
    sender: String!
}

input EmailSmtpSettingsInput {
    host: String!
    password: String
    port: Int!
    sender: String!
    useTls: Boolean!
    username: String
}

input EvaluationModelResultsFilter {
    hdiWidthReached: Boolean
    metrics: [PerformanceMetric!]
    status: [EvaluationStatus!]
    tags: [String!]
}

input EvaluationModelsFilter {
    name: String
    problemType: ProblemType
}

input EvaluationPerformanceMetricConfigInput {
    enabled: Boolean!
    hdiWidth: Float
    metric: PerformanceMetric!
    ropeLowerBound: Float
    ropeUpperBound: Float
}

input ExperimentMetricConfigInput {
    hdiWidth: Float!
    metric: String!
    ropeLowerBound: Float!
    ropeUpperBound: Float!
}

input ExperimentResultsFilter {
    hdiWidthReached: Boolean
    metric: [String!]
    status: [ExperimentStatus!]
    tags: [String!]
}

input ExperimentRuntimeConfigInput {
    metrics: [ExperimentMetricConfigInput!]!
}

input ExperimentsFilter {
    experimentType: ExperimentType
    name: String
}

input InspectDataSourceInput {
    problemType: ProblemType
    productType: ProductType! = MONITORING
    storageInfo: StorageInput!
}

input InspectExperimentDataSourceInput {
    columns: [ColumnInput!]!
    storageInfo: StorageInput!
}

input ModelResultsFilter {
    analysisTypes: [AnalysisType!]
    calculatorTypes: [CalculatorType!]
    columnNames: [String!]
    componentNames: [String!]
    metricNames: [String!]
    tags: [String!]
}

input ModelsFilter {
    name: String
    problemType: ProblemType
}

input MultivariateDriftMethodConfigInput {
    enabled: Boolean!
    method: MultivariateDriftMethod!
    threshold: ThresholdRefInput
}

input NotificationSettingsInput {
    email: EmailNotificationSettingsInput
    webhook: WebhookNotificationSettingsInput
}

input OidcProviderInput {
    audience: String!
    authority: String!
    issuer: String!
    redirectUri: String
}

input PerformanceMetricConfigInput {
    businessValue: BusinessValueMetricConfigInput
    enabled: Boolean!
    enabledEstimated: Boolean! = true
    enabledRealized: Boolean! = true
    metric: PerformanceMetric!
    threshold: ThresholdRefInput
}

input PerformanceTypeConfigInput {
    enabled: Boolean!
    type: PerformanceType!
}

input RawStorageInput {
    connectionString: String!
    options: JSON
}

input ResultDataFilter {
    endTimestamp: DateTime
    periods: [DataPeriod!]
    startTimestamp: DateTime
}

input ResultRefInput {
    analysisType: AnalysisType!
    calculatorType: CalculatorType!
    columnName: String
    componentName: String
    metricName: String
    modelId: Int!
}

input S3StorageInput {
    authenticationMode: S3AuthenticationMode!
    awsAccessKeyId: String
    awsSecretAccessKey: String
    uri: String!
}

input StandardDeviationThresholdInput {
    stdLowerMultiplier: Float
    stdUpperMultiplier: Float
}

input StorageInput {
    azureBlob: AzureBlobStorageInput
    cache: CacheStorageInput
    raw: RawStorageInput
    s3: S3StorageInput
}

input SummaryStatsMetricConfigInput {
    enabled: Boolean!
    metric: SummaryStatsMetric!
    threshold: ThresholdRefInput
}

input TagResultInput {
    resultRef: ResultRefInput!
    tagName: String!
}

input ThresholdRefInput {
    id: ID!
}

input UnivariateDriftMethodConfigInput {
    enabled: Boolean!
    enabledCategorical: Boolean!
    enabledContinuous: Boolean!
    method: UnivariateDriftMethod!
    threshold: ThresholdRefInput
}

input UserApiTokenCreateInput {
    description: String
}

input UserCredentialInput {
    email: String!
    password: String!
}

input WebhookNotificationHeaderInput {
    key: String!
    value: String!
}

input WebhookNotificationSettingsInput {
    additionalHeaders: [WebhookNotificationHeaderInput!]!
    address: String!
    enabled: Boolean
}
